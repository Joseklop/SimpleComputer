#pragma once
#ifndef SIMPLECOMPUTER_HPP
#define SIMPLECOMPUTER_HPP

#include <iostream>
#include <fstream>
#include <string>
#include <stdexcept>

/*FLAGS*/
#define OVERFLOW            0 // Gереполнение  при  выполнении  операции
#define DIVISION_BY_ZERO    1 // Ошибка деления на 0
#define OUT_OF_MEMORY       2 // Ошибка выхода за границы памяти
#define IGNORING_TACT_PULSE 3 // Игнорирование тактовых импульсов
#define INCORRECT_COMMAND   4 // Указана неверная команда

/*COMMANDS*/
#define READ   10  // Ввод с терминала в указанную ячейку памяти с контролем переполнения
#define WRITE  11  // Вывод на терминал значение указанной ячейки памяти
#define LOAD   20  // Загрузка в аккумулятор значения из указанного адреса памяти
#define STORE  21  // Выгружает значение из аккумулятора по указанному адресу памяти
#define ADD    30  // Выполняет сложение слова в аккумуляторе и слова из указанной ячейки памяти (результат в аккумуляторе)
#define SUB    31  // Вычитает из слова в аккумуляторе слово из указанной ячейки памяти (результат в аккумуляторе)
#define DIVIDE 32  // Выполняет деление слова в аккумуляторе на слово из указанной ячейки памяти (результат в аккумуляторе)
#define MUL    33  // Вычисляет произведение слова в аккумуляторе на слово из указанной ячейки памяти (результат в аккумуляторе)
#define JUMP   40  // Переход к указанному адресу памяти
#define JNEG   41  // Переход к указанному адресу памяти, если в аккумуляторе находится отрицательное число
#define JZ     42  // Переход к указанному адресу памяти, если в аккумуляторе находится отрицательное число
#define HALT   43  // Остановка, выполняется при завершении работы программы
#define NOT    51  // Двоичная инверсия слова в аккумуляторе и занесение результата в указанную ячейку памяти
#define AND    52  // Логическая операция И между содержимым аккумулятора и словом по указанному адресу (результат в аккумуляторе)
#define OR     53  // Логическая операция ИЛИ между содержимым аккумулятора и словом по указанному адресу (результат в аккумуляторе)
#define XOR    54  // Логическая операция исключающее ИЛИ между содержимым аккумулятора и словом по указанному адресу (результат в аккумуляторе)
#define JNS    55  // Переход к указанному адресу памяти, если в аккумуляторе находится положительное число
#define JC     56  // Переход к указанному адресу памяти, если при сложении произошло переполнение
#define JNC    57  // Переход к указанному адресу памяти, если при сложении не произошло переполнение
#define JP     58  // Переход к указанному адресу памяти, если результат предыдущей операции четный
#define JNP    59  // Переход к указанному адресу памяти, если результат предыдущей операции нечетный
#define CHL    60  // Логический двоичный сдвиг содержимого указанной ячейки памяти влево(результат в аккумуляторе)
#define SHR    61  // Логический двоичный сдвиг содержимого указанной ячейки памяти вправо(результат в аккумуляторе)
#define RCL    62  // Циклический двоичный сдвиг содержимого указанной ячейки памяти влево(результат в аккумуляторе)
#define RCR    63  // Циклический двоичный сдвиг содержимого указанной ячейки памяти вправо(результат в аккумуляторе)
#define NEG    64  // Получение дополнительного кода содержимого указанной ячейки памяти(результат в аккумуляторе)
#define ADDC   65  // Сложение содержимого указанной ячейки памяти с ячейкой памяти, адрес которой находится ваккумуляторе(результат в аккумуляторе)
#define SUBC   66  // Вычитание из содержимого указанной ячейки памяти содержимого ячейки памяти, адрес которой находится в аккумуляторе(результат в аккумуляторе)
#define LOGLC  67  // Логический двоичный сдвиг содержимого указанного участка памяти влево на количество разрядов указанное в аккумуляторе(результат в аккумуляторе)
#define LOGRC  68  // Логический двоичный сдвиг содержимого указанного участка памяти вправо на количестворазрядов указанное в аккумуляторе(результат в аккумуляторе)
#define RCCL   69  // Циклический двоичный сдвиг содержимого указанного участка памяти влево на количестворазрядов указанное в аккумуляторе(результат в аккумуляторе)
#define RCCR   70  // Циклический двоичный сдвиг содержимого указанного участка памяти вправо на количестворазрядов указанное в аккумуляторе(результат в аккумуляторе)
#define MOVA   71  // Перемещение содержимого указанной ячейки памяти в ячейку, адрес которой указан в аккумуляторе
#define MOVR   72  // Перемещение содержимого ячейки памяти, адрес которой содержится в аккумуляторе в указанную ячейку памяти.
#define MOVСA  73  // Перемещение содержимого указанной ячейки памяти в ячейку памяти, адрес которой находится в ячейке памяти, на которую указывает значение аккумулятора
#define MOVСR  74  // Перемещение в указанный участок памяти содержимого участка памяти, адрес которого находится в участке памяти указанном в аккумуляторе
#define ADDC   75  // Сложение содержимого указанной ячейки памяти с ячейкой памяти, адрес которой находится вячейке памяти, указанной в аккумуляторе(результат в аккумуляторе)
#define SUBC   76  // Вычитание из содержимого указанной ячейки памяти содержимого ячейки памяти, адрес которой находится в ячейке памяти, указанной в аккумуляторе(результат в аккумуляторе)



const int MEMORY_SIZE = 100;
const int REGISTER_SIZE = 5;

int memory[MEMORY_SIZE];
uint8_t regFLAGS;

int sc_memoryInit();//Инициализирует оперативную память Simple Computer

int sc_memorySet(int address, int value);//Задает значение указанной ячейки памяти, как value
int sc_memoryGet(int address, int* value);//Возвращает значение указанной ячейки памяти в value

int sc_memorySave(const std::string& filename);//Сохраняет содержимое памяти в файл
int sc_memoryLoad(const std::string& filename);//Загружает из указанного файла содержимое оперативной памяти

int sc_regInit();//Инициализирует регистр флагов

int sc_regSet(int reg, int value);//Устанавливает значение указанного регистра флагов
int sc_regGet(int reg, int* value);//Возвращает значение указанного флага

int sc_commandEncode(int command, int operand, int* value);//Кодирует команду с указанным номенром и операндом и помещаент результат в value
int sc_commandDecode(int value, int* command, int* operand);//Декодирует команду, как команду Simple Computer

#endif //SIMPLECOMPUTER_HPP